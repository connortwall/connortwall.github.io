<!DOCTYPE HTML>
<html>
    <head>
        <title>Connor Wall Portfolio</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
        <link rel="stylesheet" href="assets/css/main.css" />
        <link rel="stylesheet" href="assets/css/tomorrow-night.min.css">
        <link rel="stylesheet" href="assets/css/sunburst.css">
        <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
        <noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
    </head>
    <body class="is-preload">

        <!-- Wrapper -->
        <div id="wrapper">

            <!-- Header -->
            <header id="header" class="alt">
                <a href="home.html" class="logo"><strong>Connor Wall</strong> <span>Portfolio</span></a>
                <nav>
                    <a href="#menu">Menu</a>
                </nav>
            </header>

            <!-- Menu -->
            <nav id="menu">
                <ul class="actions stacked">
                    <li><a href="home.html" class="button fit">Home</a></li>
                </ul>
                <ul class="links">
                    <li><a href="coding.html">Coding</a></li>
                    <li><a href="gamedesign.html">Game Design</a></li>
                    <li><a href="visualart.html">Digital Illustration</a></li>
                    <li><a href="writtenwork.html">Written Work</a></li>
                </ul>
                <ul class="actions stacked">
                    <!--<li><a href="CV.html" class="button icon solid primary fas fa-clipboard-list">CV</a></li>-->
                    <li><a href="CV.html" class="button primary fit fas fa-clipboard-list">CV</a></li>
                </ul>
            </nav>

            <!-- Main -->
            <section id="banner" class="major">
                <div class="inner">
                    <span class="image">
                        <img src="uploads/ConnorWall_Portfolio/Game_Design/Roboleon/logo.png" alt=""/></span>
                    <header class="major">
                        <h2>
										<span style="font-size: 300%;">
											Roboleon
										</span>
                        </h2>
                        <p>Scroll to see more</p>
                    </header>
                </div>
            </section>
            <div id="main" class="alt">

                <!-- One -->
                <section id="one">

                    <div class="inner">
                        <header class="major">
                            <h1>Project Information</h1>
                        </header>
                        <img : width=100% height=100% src="uploads/ConnorWall_Portfolio/Game_Design/Roboleon/logo.png">
                        <p><img src="uploads/ConnorWall_Portfolio/Game_Design/Roboleon/Onepager.Final3.png"
                                   width="100%" height="600px;"></img></p>

                        <br>
                        <p>I programmed <b>save - load</b>, <b>procedural obstacle generation</b>, <b>UI</b>, and <b>localization</b> systems for an 3rd-person dark, comedic, narrative RPG game in Unity's HDRP.</p>
                        <header class="major">
                            <h1>Gameplay</h1>
                        </header>
                        <p><img src="uploads/ConnorWall_Portfolio/Game_Design/Roboleon/gifs/GG_jumpingInCargoBay.gif"
                                width="100%" height="600px;"></img></p>
                        <p><img src="uploads/ConnorWall_Portfolio/Game_Design/Roboleon/gifs/GG_attachmentSwitch.gif"
                                width="100%" height="600px;"></img></p>
                        <p><img src="uploads/ConnorWall_Portfolio/Game_Design/Roboleon/gifs/GG_ChangeLanguage.gif"
                                width="100%" height="600px;"></img></p>

                        <ul class="actions">
                            <li><a href="" class="button icon solid fa-gamepad">Download (Releasing on Dec 4)</a></li>
                            <li><a href="https://github.com/connortwall/Robolleon-Game" class="button icon solid brands fa-github">Github (Releasing on Dec 4)</a></li>
                            <li><a href="uploads/ConnorWall_Portfolio/Game_Design/Roboleon/Technical%20Design%20Document.pdf" class="button icon solid primary fa-clipboard-list">Technical Presentation</a></li>

                        </ul>
                    </div>

                </section>

            </div>

            <!--Project Description-->

            <div class="pp-contents">
                <header class="major">
                    <h1>More Project Information</h1>
                </header>
                <div class="accordion">
                    <i class="fa fa-info" aria-hidden="true"></i>
                    <span style="margin-left: 5px;">Save - Load</span>
                    <div class="accordion-icon">
                        <i class="fa fa-times" aria-hidden="true"></i>
                    </div>
                </div>
                <div class="accordion-inner">
                    <p>I developed a Save - Load system.</p>
                    <div class="accordion">
                        <i class="fa fa-code" aria-hidden="true"></i>
                        <span style="margin-left: 5px;">CODE SNIPPET - Save Load</span>
                        <div class="accordion-icon">
                            <i class="fa fa-times" aria-hidden="true"></i>
                        </div>
                    </div>
                    <div class="accordion-inner">
                        <p>The following code demonstrates the algorithm used to spawn game objects in the game scene</p>
                        <pre class="prettyprint lang-csharp">
                            public class FireSpawner : MonoBehaviour
{

    [Header("Fire Prefabs to use")]
    public List<GameObject> firePrefabs;
    [Header("Tuning")]
    public Vector2 zone = Vector2.one;
    public float spaceBetweenFires = 1;
    public float prefabScale = 1;
    private int k = 2;
    private List<Vector2> samples;

    public List<GameObject> StartFire()
    {
        List<GameObject> fireObjects = new List<GameObject>();
        samples = Poisson.GeneratePoint(spaceBetweenFires, zone, k);
        if(samples != null)
        {
            int index;
            foreach(Vector2 sample in samples)
            {

                //instantiate fire
                index = Random.Range(0, firePrefabs.Count);
                GameObject fire = Instantiate(firePrefabs[index], new Vector3(sample.x, 0, sample.y)+transform.position, Quaternion.identity)as GameObject;
                Assert.IsNotNull(fire.GetComponent<FireObject>());
                fire.transform.Rotate(0, Random.Range(0, 360), 0);
                fire.transform.localScale = Vector3.one * prefabScale;
                //add fire to fire list
                fireObjects.Add(fire);
            }
        }
        // if by chance no fires are added to the scene in each sample (i.e count = 0) spawn a fire in the middle of the hub
        if (fireObjects.Count <= 0)
        {
            // instantiate fire in middle of fire spawner zone
            GameObject fire = Instantiate(firePrefabs[0], new Vector3(zone.x/2, 0, zone.y/2)+transform.position, Quaternion.identity)as GameObject;
            fireObjects.Add(fire);
        }

        if (fireObjects.Count > 0) return fireObjects;
        else return null;
    }

    private void OnDrawGizmos()
    {
        Gizmos.color = Color.yellow;
        Gizmos.DrawWireCube((new Vector3(zone.x, 0, zone.y) / 2)+transform.position, new Vector3(zone.x, 0, zone.y));

    }

}
                        </pre>
                        <p>The following code is part of procedural algortihm itself:</p>

                        <pre class="prettyprint lang-csharp">public static List<Vector2> GeneratePoint(float radius, Vector2 grid_size, int numSamplesBeforeRejection  = 30)
    {
        // find the size of a cell's square
        float cell_size = radius / Mathf.Sqrt(2);

        // number of times the cell size fits into sample region size, for each cell
        // grid will tell us for each cell, what the index is of each point, (0 means no point, 1 has index 0)
        // to get the number of columns divide the width / cell_size and rows
        int[,] grid = new int[Mathf.CeilToInt(grid_size.x / cell_size), Mathf.CeilToInt(grid_size.y / cell_size)];

        // create new vectors of sample candidate points
        List<Vector2> samples = new List<Vector2>();
        List<Vector2> spawn_samples = new List<Vector2>();

        // create spawn point list
        spawn_samples.Add(grid_size / 2);
        // while spawn point list is not empty
        while (spawn_samples.Count > 0)
        {
            int index = Random.Range(0, spawn_samples.Count);
            Vector2 current_spawn_sample = spawn_samples[index];
            bool rejected_sample = true;
            for (int i = 0; i < numSamplesBeforeRejection; i++)
            {
                // angle of candidate point
                float angle_offset = Random.value * Mathf.PI * 2;
                //rotate a vector at a given angle
                float x = Mathf.Sin(angle_offset);
                float y = Mathf.Cos(angle_offset);

                Vector2 offset_direction = new Vector2(x, y);

                // new magnitude
                // radius is min so that candidate is spawned outside spawn center
                float new_magnitude = Random.Range(radius, 2 * radius);
                offset_direction *= new_magnitude;

                // assign info to sample
                Vector2 sample = current_spawn_sample + offset_direction;
                if (is_valid(samples, grid, sample, grid_size, radius, cell_size))
                {
                    // add sample to point list
                    samples.Add(sample);
                    // add sample as new spawn point
                    spawn_samples.Add(sample);
                    // record which cell the sample point ends up in
                    grid[(int)(sample.x / cell_size), (int)(sample.y / cell_size)] = samples.Count;
                    rejected_sample = false;
                    break;
                }
            }

            // if not accepted remove from spawn point list
            if (rejected_sample)
            {
                spawn_samples.RemoveAt(index);
            }
        }
        return samples;
    }</pre>


                    </div>

                    <div class="accordion-inner">

                        <p><img src="uploads/ConnorWall_Portfolio/Game_Design/Roboleon/gifs/GG_puttingOutFire.gif"
                                style="font-style:normal;font-weight:normal;font-size:15px;font-family:Arial, 'Helvetica Neue', Helvetica, Tahoma, sans-serif;vertical-align:middle;height:auto;background-color:rgb(255,255,255);"/><img
                            <!--src="http://hugo.fyi/assets/statemachine3.png" alt="statemachine3.png#asset:38"
                            style="font-style:normal;font-weight:normal;font-size:15px;font-family:Arial, 'Helvetica Neue', Helvetica, Tahoma, sans-serif;vertical-align:middle;height:auto;background-color:rgb(255,255,255);"/>-->
                        </p>


                    </div>

                </div>

                <div class="accordion">
                    <i class="fa fa-info" aria-hidden="true"></i>
                    <span style="margin-left: 5px;">Procedural Obstacle Generation</span>
                    <div class="accordion-icon">
                        <i class="fa fa-times" aria-hidden="true"></i>
                    </div>
                </div>
                <div class="accordion-inner">
                    <p>I developed a procedural object spawner using Poisson Disk Sampling.</p>
                    <div class="accordion">
                        <i class="fa fa-code" aria-hidden="true"></i>
                        <span style="margin-left: 5px;">CODE SNIPPET - Procedural Fire Spawning</span>
                        <div class="accordion-icon">
                            <i class="fa fa-times" aria-hidden="true"></i>
                        </div>
                    </div>
                    <div class="accordion-inner">
                        <p>The following code demonstrates the algorithm used to spawn game objects in the game scene</p>
                        <pre class="prettyprint lang-csharp">
                            public class FireSpawner : MonoBehaviour
{

    [Header("Fire Prefabs to use")]
    public List<GameObject> firePrefabs;
    [Header("Tuning")]
    public Vector2 zone = Vector2.one;
    public float spaceBetweenFires = 1;
    public float prefabScale = 1;
    private int k = 2;
    private List<Vector2> samples;

    public List<GameObject> StartFire()
    {
        List<GameObject> fireObjects = new List<GameObject>();
        samples = Poisson.GeneratePoint(spaceBetweenFires, zone, k);
        if(samples != null)
        {
            int index;
            foreach(Vector2 sample in samples)
            {

                //instantiate fire
                index = Random.Range(0, firePrefabs.Count);
                GameObject fire = Instantiate(firePrefabs[index], new Vector3(sample.x, 0, sample.y)+transform.position, Quaternion.identity)as GameObject;
                Assert.IsNotNull(fire.GetComponent<FireObject>());
                fire.transform.Rotate(0, Random.Range(0, 360), 0);
                fire.transform.localScale = Vector3.one * prefabScale;
                //add fire to fire list
                fireObjects.Add(fire);
            }
        }
        // if by chance no fires are added to the scene in each sample (i.e count = 0) spawn a fire in the middle of the hub
        if (fireObjects.Count <= 0)
        {
            // instantiate fire in middle of fire spawner zone
            GameObject fire = Instantiate(firePrefabs[0], new Vector3(zone.x/2, 0, zone.y/2)+transform.position, Quaternion.identity)as GameObject;
            fireObjects.Add(fire);
        }

        if (fireObjects.Count > 0) return fireObjects;
        else return null;
    }

    private void OnDrawGizmos()
    {
        Gizmos.color = Color.yellow;
        Gizmos.DrawWireCube((new Vector3(zone.x, 0, zone.y) / 2)+transform.position, new Vector3(zone.x, 0, zone.y));

    }

}
                        </pre>
                        <p>The following code is part of procedural algortihm itself:</p>

                        <pre class="prettyprint lang-csharp">public static List<Vector2> GeneratePoint(float radius, Vector2 grid_size, int numSamplesBeforeRejection  = 30)
    {
        // find the size of a cell's square
        float cell_size = radius / Mathf.Sqrt(2);

        // number of times the cell size fits into sample region size, for each cell
        // grid will tell us for each cell, what the index is of each point, (0 means no point, 1 has index 0)
        // to get the number of columns divide the width / cell_size and rows
        int[,] grid = new int[Mathf.CeilToInt(grid_size.x / cell_size), Mathf.CeilToInt(grid_size.y / cell_size)];

        // create new vectors of sample candidate points
        List<Vector2> samples = new List<Vector2>();
        List<Vector2> spawn_samples = new List<Vector2>();

        // create spawn point list
        spawn_samples.Add(grid_size / 2);
        // while spawn point list is not empty
        while (spawn_samples.Count > 0)
        {
            int index = Random.Range(0, spawn_samples.Count);
            Vector2 current_spawn_sample = spawn_samples[index];
            bool rejected_sample = true;
            for (int i = 0; i < numSamplesBeforeRejection; i++)
            {
                // angle of candidate point
                float angle_offset = Random.value * Mathf.PI * 2;
                //rotate a vector at a given angle
                float x = Mathf.Sin(angle_offset);
                float y = Mathf.Cos(angle_offset);

                Vector2 offset_direction = new Vector2(x, y);

                // new magnitude
                // radius is min so that candidate is spawned outside spawn center
                float new_magnitude = Random.Range(radius, 2 * radius);
                offset_direction *= new_magnitude;

                // assign info to sample
                Vector2 sample = current_spawn_sample + offset_direction;
                if (is_valid(samples, grid, sample, grid_size, radius, cell_size))
                {
                    // add sample to point list
                    samples.Add(sample);
                    // add sample as new spawn point
                    spawn_samples.Add(sample);
                    // record which cell the sample point ends up in
                    grid[(int)(sample.x / cell_size), (int)(sample.y / cell_size)] = samples.Count;
                    rejected_sample = false;
                    break;
                }
            }

            // if not accepted remove from spawn point list
            if (rejected_sample)
            {
                spawn_samples.RemoveAt(index);
            }
        }
        return samples;
    }</pre>


                    </div>

                    <div class="accordion-inner">

                        <p><img src="uploads/ConnorWall_Portfolio/Game_Design/Roboleon/gifs/GG_puttingOutFire.gif"
                                style="font-style:normal;font-weight:normal;font-size:15px;font-family:Arial, 'Helvetica Neue', Helvetica, Tahoma, sans-serif;vertical-align:middle;height:auto;background-color:rgb(255,255,255);"/><img
                            <!--src="http://hugo.fyi/assets/statemachine3.png" alt="statemachine3.png#asset:38"
                            style="font-style:normal;font-weight:normal;font-size:15px;font-family:Arial, 'Helvetica Neue', Helvetica, Tahoma, sans-serif;vertical-align:middle;height:auto;background-color:rgb(255,255,255);"/>-->
                        </p>


                    </div>

                </div>

                <div class="accordion">
                    <i class="fa fa-info" aria-hidden="true"></i>
                    <span style="margin-left: 5px;">Full Technical Design Document</span>
                    <div class="accordion-icon">
                        <i class="fa fa-times" aria-hidden="true"></i>
                    </div>
                </div>
                <div class="accordion-inner">
                    <p><iframe src="uploads/ConnorWall_Portfolio/Game_Design/Roboleon/Technical%20Design%20Document.pdf"
                               width="100%" height="600px;"></iframe></p></p>

                </div>

                <div class="accordion">
                    <i class="fa fa-info" aria-hidden="true"></i>
                    <span style="margin-left: 5px;">Executive Summary</span>
                    <div class="accordion-icon">
                        <i class="fa fa-times" aria-hidden="true"></i>
                    </div>
                </div>
                <div class="accordion-inner">
                    <p><iframe src="uploads/ConnorWall_Portfolio/Game_Design/Roboleon/Executive%20Summary.pdf"
                            width="100%" height="600px"></iframe></p></p>

                </div>




                <!--
                <div class="accordion">
                    <i class="fa fa-shield" aria-hidden="true"></i>
                    <span style="margin-left: 5px;">Combat System (melee, ranged, shielded)</span>
                    <div class="accordion-icon">
                        <i class="fa fa-times" aria-hidden="true"></i>
                    </div>
                </div>
                <div class="accordion-inner">

                    <p>Bolt Storm features both ranged (gun, crossbow) and melee (sword, knife) combat. To allow
                        for these different types of weapons, I set up a system which can map bones ('sockets')
                        of characters to a specific slot, so that weapons can be used on different skeletons.
                        The slot definitions, weapons themselves, and even the local binding have local offsets,
                        to fine-tune the position in every case.</p>

                    <div style="text-align: left; margin-bottom: 10px;">
                        <video autoplay muted loop style="	max-width: 100%; max-height: 100%;">
                            <source src="http://hugo.fyi/assets/projects/378/BoltStorm-Combat1.mp4"
                                    type="video/mp4"/>
                        </video>
                    </div>
                    <div style="text-align: left; margin-bottom: 10px;">
                        <video autoplay muted loop style="	max-width: 100%; max-height: 100%;">
                            <source src="http://hugo.fyi/assets/projects/379/bs-combat-3.mp4" type="video/mp4"/>
                        </video>
                    </div>
                    <h2>Custom 'melee' collision checking</h2>

                    <p>
                    <p>Swords swing pretty fast, meaning the default collision checking wasn't optimal in our
                        case. We also wanted collision checking 'LODs', in other words; being able to have less
                        precise collision checking in cases where precision doesn't really matter.
                    </p>
                    <p>In the case of Bolt Storm, there can be armies of knights fighting, so collision hits can
                        be guessed, instead of checked very precisely.
                        For 1-on-1 combat, I implemented collision checking by having a set of boxes on the
                        weapon which define what is collidable, then each frame the previous position of each
                        box is traced against the current position of that box.</p>
                    <p>Visually, that looks like this:</p>
                    <p><img src="http://i.imgur.com/TY8eHYA.gif" alt="TY8eHYA.gif"
                            style="vertical-align:middle;height:auto;"/></p></p>


                    <div class="accordion">
                        <i class="fa fa-code" aria-hidden="true"></i>
                        <span style="margin-left: 5px;">CODE SNIPPET - Melee collision checking</span>
                        <div class="accordion-icon">
                            <i class="fa fa-times" aria-hidden="true"></i>
                        </div>
                    </div>
                    <div class="accordion-inner">

                 			    	    	    		    		<pre class="prettyprint linenums">TArray&lt;FHitResult&gt; FBsWpCollisionPreciseBox::UpdateCollision(AActor* aActor)
{
	UWorld* tWorld = aActor->GetWorld();

	TArray&lt;FHitResult&gt; tOutResult;

	for (int i = 0; i < mCachedComps.Num(); i++)
	{
		const UBoxComponent* tComp = mCachedComps[i];

		FTransform& tPrevTransform = mCachedTransforms[i];
		FTransform tCurTransform = tComp->GetComponentToWorld();

		FVector BoxExt = tComp->GetScaledBoxExtent();

		TArray&lt;FHitResult&gt; tThisOutResult;
		FCollisionQueryParams tQueryParams = FCollisionQueryParams::DefaultQueryParam;
		FCollisionResponseParams tResponseParams = FCollisionResponseParams::DefaultResponseParam;
		FCollisionObjectQueryParams tObjectQueryParams = FCollisionObjectQueryParams::AllObjects;

		/* Add the weapon */
		tQueryParams.AddIgnoredActor(tComp->GetOwner());
		/* Add the weapon's owner (character) */
		tQueryParams.AddIgnoredActor(tComp->GetOwner()->GetOwner());

		if (tWorld->SweepMultiByObjectType(tThisOutResult,
			tPrevTransform.GetTranslation(), tCurTransform.GetTranslation(), tPrevTransform.GetRotation(),
			tObjectQueryParams, FCollisionShape::MakeBox(BoxExt / 2.f), tQueryParams))
		{
			tOutResult.Append(tThisOutResult);
		}

		mCachedTransforms[i] = tCurTransform;
	}

	return tOutResult;
}</pre>


                    </div>

                    <h2>State Machine &amp; Combat System in action</h2>

                    <p>
                    <p>The following demonstrates the character logic and the combat system in action, notice
                        how the character rotation locks while he swings the sword, and waits until the attack
                        is over before rotating back.</p></p>

                    <div style="text-align: left; margin-bottom: 10px;">
                        <video autoplay muted loop style="	max-width: 100%; max-height: 100%;">
                            <source src="http://hugo.fyi/assets/projects/395/boltstorm_1_ffmpeg2.mp4"
                                    type="video/mp4"/>
                        </video>
                    </div>


                </div>
                <div class="accordion">
                    <i class="fa fa-cubes" aria-hidden="true"></i>
                    <span style="margin-left: 5px;">Ranged Combat &amp; Projectile Batching</span>
                    <div class="accordion-icon">
                        <i class="fa fa-times" aria-hidden="true"></i>
                    </div>
                </div>
                <div class="accordion-inner">

                    <p>I implemented a system that allows us to have many (<em>many</em>) projectiles on the
                        screen at the same time. It works like this</p>

                    <p>
                    <ul>
                        <li>When a projectile is fired, submit the data to a global actor which manages them
                        </li>
                        <li>In the actor, check if an Instanced Static Mesh Component (ISM component) exists for
                            the mesh of the projectile
                            <ul>
                                <li> If not, create two new components:
                                    <ul>
                                        <li>One will be used for while the projectile is moving, constantly
                                            updating the mesh from the CPU
                                        </li>
                                        <li>The other will be used exclusively for static projectiles (laying
                                            still on the ground)
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>Create a physics body for the projectile (derived of Primitive Component, not an
                            actor), but do not use it for now, just keep setting the velocity from the next
                            step:
                        </li>
                        <li>Initialize custom physics code (used to calculate projectile arcs for AI)</li>
                        <li>Submit an instance to the "moving" ISM component</li>
                        <li>&lt; update the projectile &amp; custom physics &gt;</li>
                        <li>When it touches an object, the physics body is put to use, from now on the
                            projectile won't cause a "hit" if it touches a character
                        </li>
                        <li>The physics body causes the projectile to fall down / slide in a natural way</li>
                        <li>When the projectile has come to a stop, its physics body is destroyed, and the
                            instance is moved from the "moving" ISM component to the "static" ISM component
                        </li>
                        <li>After a while it's also removed from this component, completely destroying the
                            projectile
                        </li>
                    </ul>
                    <p>This approach has allowed us to have as many as 27,000 moving projectiles on the screen
                        simulatenously, and over 230,000 static projectiles. With actors, this number was far
                        below 1,000 (test situation: a pretty much empty scene in UE4 on a desktop with a
                        GTX 770, i7 4770k)</p></p>

                    <div style="text-align: left; margin-bottom: 10px;">
                        <video autoplay muted loop style="	max-width: 100%; max-height: 100%;">
                            <source src="http://hugo.fyi/assets/projects/388/boltstorm_2_ffmpeg2.mp4"
                                    type="video/mp4"/>
                        </video>
                    </div>
                    <p>Projectiles can be spawned in "bursts", each burst can have a root offset, and a local
                        offset per projectile, allowing for shapes of projectiles:</p>

                    <p>
                    <p><img src="http://i.imgur.com/jpv0zxN.gif" alt="jpv0zxN.gif"
                            style="vertical-align:middle;height:auto;"/></p>
                    <p><img src="http://i.imgur.com/2R6iG4t.gif" alt="2R6iG4t.gif"
                            style="vertical-align:middle;height:auto;"/></p></p>


                </div>
                <div class="accordion">
                    <i class="fa fa-desktop" aria-hidden="true"></i>
                    <span style="margin-left: 5px;">User Interface implementation</span>
                    <div class="accordion-icon">
                        <i class="fa fa-times" aria-hidden="true"></i>
                    </div>
                </div>
                <div class="accordion-inner">

                    <p>I designed and developed some UI elements for Bolt Storm, for example, a widget that
                        slides open to reveal information about an item that you can buy (swords, crossbows,
                        etc). It compares your currently-equipped item with the one you're able to buy.</p>

                    <div style="text-align: left; margin-bottom: 10px;">
                        <video autoplay muted loop style="	max-width: 100%; max-height: 100%;">
                            <source src="http://hugo.fyi/assets/projects/404/BS-Shop-UI.mp4" type="video/mp4"/>
                        </video>
                    </div>
                    <p>Furthermore I re-used this design to make a small "context popup" which informs the user
                        about necessary information during gameplay, like a message that tells the player to
                        defeat more enemies before being able to exit the level:</p>

                    <div style="text-align: left; margin-bottom: 10px;">
                        <video autoplay muted loop style="	max-width: 100%; max-height: 100%;">
                            <source src="uploads/ConnorWall_Portfolio//projects/406/ContextFeedback.mp4"
                                    type="video/mp4"/>
                        </video>
                    </div>


                </div>
                <div class="accordion">
                    <i class="fa fa-paint-brush" aria-hidden="true"></i>
                    <span style="margin-left: 5px;">Formation Selection Shader</span>
                    <div class="accordion-icon">
                        <i class="fa fa-times" aria-hidden="true"></i>
                    </div>
                </div>
                <div class="accordion-inner">

                    <p>In Bolt Storm you can command your army to attack a certain group of enemies. I wrote
                        a shader consisting of two passes (a pre-tonemap and post-tonemap pass) to visualize the
                        selection. <em>Note: this is still a work in progress!</em></p>

                    <p>
                    <p><img src="http://hugo.fyi/assets/6uzRMGh.jpg" alt="6uzRMGh.jpg#asset:247"
                            style="vertical-align:middle;height:auto;"/></p>
                    <h3>How it works</h3>
                    <p>Let's take this shot for example:</p>
                    <p><img src="http://i.imgur.com/zHALbLK.jpg" alt="zHALbLK.jpg"
                            style="vertical-align:middle;height:auto;"/></p>
                    <p>All character meshes, the weapon meshes and the icons are rendered to the custom depth
                        and stencil buffers:</p>
                    <p><img src="http://i.imgur.com/yn8WfHM.png" alt="yn8WfHM.png"
                            style="vertical-align:middle;height:auto;"/></p>
                    <p>At the moment, the stencil values are a hardcoded "enum" value, but this will most likely
                        change to a bit mask.</p>
                    <p>Next the pre-tonemap shader is applied, coloring the areas defined by the stencil
                        values:</p>
                    <p><img src="http://i.imgur.com/F5jHWfU.jpg" alt="F5jHWfU.jpg"
                            style="vertical-align:middle;height:auto;"/></p>
                    <p>Then the post-tonemap shader is applied to the screen, except for the stencil values:</p>
                    <p><img src="http://i.imgur.com/mNk0PA0.png" alt="mNk0PA0.png"
                            style="vertical-align:middle;height:auto;"/></p>
                    <p>(The screenshot above is without the pre-tonemap shader applied).</p>
                    <p>The combined result:</p>
                    <p><img src="http://i.imgur.com/E4WrEgg.png" alt="E4WrEgg.png"
                            style="vertical-align:middle;height:auto;"/></p>
                    <p>At the moment the shaders identify the objects by a number of if-statements, this will
                        soon be optimized by making the stencil values a bitmask.</p>
                    <p>The pre-tonemap shader fills a color on an area marked with specific stencil values
                        (first desaturates it to prevent lighting influence), and then applies a Fresnel on top
                        of that (where every one of the colored squares is a section for one specific
                        object):</p>
                    <p><img src="http://i.imgur.com/4nFSDCn.png" alt="4nFSDCn.png"
                            style="vertical-align:middle;height:auto;"/></p>
                    <p>The post-tonemap shader first determines if the stencil value is targeted to an object,
                        if not it desaturates the fragment - applies a blur and blends color based on the
                        scene depth as well as different blend colors. It looks like this:</p>
                    <p><img src="http://i.imgur.com/tfcrX6R.png" alt="tfcrX6R.png"
                            style="vertical-align:middle;height:auto;"/></p></p>


                </div>
                -->
            </div>


            <!-- Footer -->
            <footer id="footer">
                <div class="inner">
                    <header class="major">
                        <h2>Get in Touch</h2>
                        <ul class="actions">
                            <li><a href="CV.html" class="button icon solid primary fas fa-clipboard-list">CV</a></li>
                            <!--<li><a href="cwall6@jhu.edu" class="button primary">email</a></li>-->
                            <li><a href="https://github.com/connortwall" class="button icon solid brands fa-github">Github<span class="label">GitHub</span></a></li>
                            <li><a href="https://www.linkedin.com/in/connortwall/" class="button icon solid brands fa-linkedin-in">LinkedIn<span class="label">LinkedIn</span></a></li>
                            <li><a href="https://connorthewall.itch.io" class="button icon solid fa-gamepad">Itch.io<span class="label">Itch.io</span></a></li>
                        </ul>
                        <ul class="copyright">
                            <li>&copy; Connor Wall</li>
                        </ul>
                    </header>
                </div>
            </footer>



        </div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>
